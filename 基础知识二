继 承（面向对象特征之一）
java中对于继承，java只支持单继承。java虽然不直接支持多继承，但是可实现多接口。

 

1：成员变量。

     当子父类中出现一样的属性时，子类类型的对象，调用该属性，值是子类的属性值。

     如果想要调用父类中的属性值，需要使用一个关键字：super

     This：代表是本类类型的对象引用。

     Super：代表是子类所属的父类中的内存空间引用。

     注意：子父类中通常是不会出现同名成员变量的，因为父类中只要定义了，子类就不用在定义了，直接继承过来用就可以了。

2：成员函数。

当子父类中出现了一模一样的方法时，建立子类对象会运行子类中的方法。好像父类中的方法被覆盖掉一样。所以这种情况，是函数的另一个特性：重写

3：构造函数。

发现子类构造函数运行时，先运行了父类的构造函数。为什么呢?

原因：子类的所有构造函数中的第一行，其实都有一条隐身的语句super();

super(): 表示父类的构造函数，并会调用于参数相对应的父类中的构造函数。而super():是在调用父类中空参数的构造函数。

为什么子类对象初始化时，都需要调用父类中的函数？(为什么要在子类构造函数的第一行加入这个super()?)

因为子类继承父类，会继承到父类中的数据，所以必须要看父类是如何对自己的数据进行初始化的。所以子类在进行对象初始化时，先调用父类的构造函数，这就是子类的实例化过程。

 

注意：子类中所有的构造函数都会默认访问父类中的空参数的构造函数，因为每一个子类构造内第一行都有默认的语句super();

如果父类中没有空参数的构造函数，那么子类的构造函数内，必须通过super语句指定要访问的父类中的构造函数。

如果子类构造函数中用this来指定调用子类自己的构造函数，那么被调用的构造函数也一样会访问父类中的构造函数。

 

问题：

super()和this()是否可以同时出现的构造函数中？

两个语句只能有一个定义在第一行，所以只能出现其中一个。

super()或者this():为什么一定要定义在第一行？

因为super()或者this()都是调用构造函数，构造函数用于初始化，所以初始化的动作要先完成。

 

在方法覆盖时，注意两点：

1：子类覆盖父类时，必须要保证，子类方法的权限必须大于等于父类方法权限可以实现继承。否则，编译失败。（举个例子，在父类中是public的方法，如果子类中将其降低访问权限为private，那么子类中重写以后的方法对于外部对象就不可访问了，这个就破坏了继承的含义）

2：覆盖时，要么都静态，要么都不静态。 (静态只能覆盖静态，或者被静态覆盖)

 

继承的一个弊端：打破了封装性。对于一些类，或者类中功能，是需要被继承，或者复写的。

这时如何解决问题呢？介绍一个关键字，final。

 

final特点：（详细解释见前面）

1：这个关键字是一个修饰符，可以修饰类，方法，变量。

2：被final修饰的类是一个最终类，不可以被继承。

3：被final修饰的方法是一个最终方法，不可以被覆盖。

4：被final修饰的变量是一个常量，只能赋值一次。

 

抽象类: abstract

抽象类的特点：

1：抽象方法只能定义在抽象类中，抽象类和抽象方法必须由abstract关键字修饰（可以描述类和方法，不可以描述变量）。

2：抽象方法只定义方法声明，并不定义方法实现。

3：抽象类不可以被创建对象(实例化)。

4：只有通过子类继承抽象类并覆盖了抽象类中的所有抽象方法后，该子类才可以实例化。否则，该子类还是一个抽象类。

 

抽象类的细节：

1：抽象类中是否有构造函数？有，用于给子类对象进行初始化。

2：抽象类中是否可以定义非抽象方法？

    可以。其实，抽象类和一般类没有太大的区别，都是在描述事物，只不过抽象类在描述事物时，有些功能不具体。所以抽象类和一般类在定义上，都是需要定义属性和行为的。只不过，比一般类多了一个抽象函数。而且比一般类少了一个创建对象的部分。

3：抽象关键字abstract和哪些不可以共存？final ,    private , static

4：抽象类中可不可以不定义抽象方法？可以。抽象方法目的仅仅为了不让该类创建对象。

 

 

接 口：★★★★★
1：是用关键字interface定义的。

2：接口中包含的成员，最常见的有全局常量、抽象方法。

注意：接口中的成员都有固定的修饰符。

    成员变量：public static final

    成员方法：public abstract

interface Inter{

    public static final int x = 3;

    public abstract void show();

}

3：接口中有抽象方法，说明接口不可以实例化。接口的子类必须实现了接口中所有的抽象方法后，该子类才可以实例化。否则，该子类还是一个抽象类。

4：类与类之间存在着继承关系，类与接口中间存在的是实现关系。

    继承用extends ；实现用implements ；

5：接口和类不一样的地方，就是，接口可以被多实现，这就是多继承改良后的结果。java将多继承机制通过多现实来体现。

6：一个类在继承另一个类的同时，还可以实现多个接口。所以接口的出现避免了单继承的局限性。还可以将类进行功能的扩展。

7：其实java中是有多继承的。接口与接口之间存在着继承关系，接口可以多继承接口。

java类是单继承的。classB Extends classA

java接口可以多继承。Interface3 Extends Interface0, Interface1, interface……

不允许类多重继承的主要原因是，如果A同时继承B和C，而b和c同时有一个D方法，A如何决定该继承那一个呢？

但接口不存在这样的问题，接口全都是抽象方法继承谁都无所谓，所以接口可以继承多个接口。

 

抽象类与接口：

抽象类：一般用于描述一个体系单元，将一组共性内容进行抽取，特点：可以在类中定义抽象内容让子类实现，可以定义非抽象内容让子类直接使用。它里面定义的都是一些体系中的基本内容。

接口：一般用于定义对象的扩展功能，是在继承之外还需这个对象具备的一些功能。

 

抽象类和接口的共性：都是不断向上抽取的结果。

 

抽象类和接口的区别：

1：抽象类只能被继承，而且只能单继承。

接口需要被实现，而且可以多实现。

2：抽象类中可以定义非抽象方法，子类可以直接继承使用。

接口中都是抽象方法，需要子类去实现。

3：抽象类使用的是 is a 关系。

接口使用的 like a 关系。

4：抽象类的成员修饰符可以自定义。

接口中的成员修饰符是固定的。全都是public的。

 

多 态★★★★★
多 态★★★★★（面向对象特征之一）：函数本身就具备多态性，某一种事物有不同的具体的体现。

 

体现：父类引用或者接口的引用指向了自己的子类对象。//Animal a = new Cat();父类可以调用子类中覆写过的（父类中有的方法）

多态的好处：提高了程序的扩展性。继承的父类或接口一般是类库中的东西，（如果要修改某个方法的具体实现方式）只有通过子类去覆写要改变的某一个方法，这样在通过将父类的应用指向子类的实例去调用覆写过的方法就行了！

多态的弊端：当父类引用指向子类对象时，虽然提高了扩展性，但是只能访问父类中具备的方法，不可以访问子类中特有的方法。(前期不能使用后期产生的功能，即访问的局限性)

多态的前提：

    1：必须要有关系，比如继承、或者实现。

    2：通常会有覆盖操作。

 

如果想用子类对象的特有方法，如何判断对象是哪个具体的子类类型呢？

可以可以通过一个关键字 instanceof ;//判断对象是否实现了指定的接口或继承了指定的类

 

格式：<对象 instanceof 类型> ，判断一个对象是否所属于指定的类型。

Student instanceof Person = true;//student继承了person类
